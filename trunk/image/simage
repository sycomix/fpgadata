#!/usr/bin/perl -w
# 2017-08-28  William A. Hudson

# simage -- Stream data into an image display.
# Uses PerlTk to do the imaging.
#
# Maintenance comments:  #!!
# Derived from:  swcap_spice/trunk/swcap  (2017-08-28)
#
#---------------------------------------------------------------------------

use strict;

use Getopt::Long  ();
use Pod::Usage    ( 'pod2usage' );

use FindBin qw($RealBin);

our $ToolDir;
BEGIN
{
    $ToolDir = $RealBin;
}

use lib "$ToolDir";		# Libraries from this tool installation.

use ImTop         ();		# Top-level class.
use ImStream      ();		# Image Stream data class.


our $ProgFile = $0;	# this program
our $ProgName = $0;
    $ProgName =~ s:^.*/:: ;

#---------------------------------------------------------------------------
## Main program usage
#---------------------------------------------------------------------------

# Print program usage.
#    May show configuration defaults.
# call:
#    print_usage()
# return:
#    ()  = unused
#    Does NOT exit, let main program decide that.
#
sub print_usage
{
    pod2usage( {
	-message => "Stream FPGA data into an image display",
	-exitval => "NOEXIT",
	-verbose => 0,
    } );

    1;
}


#---------------------------------------------------------------------------
## Main program
#---------------------------------------------------------------------------

{
    select( STDOUT );  $| = 1;	# autoflush
    select( STDERR );  $| = 1;
    # Leave STDERR selected to protect data stream.

## Option processing.

    my $op_verbose      = 0;
    my $op_TESTOP       = 0;
    my $op_npix         = 10;
    my $op_nx           = 256;
    my $op_ny           = 256;
    my $op_magnify      = 1;
    my $op_wrap         = 1;

    Getopt::Long::Configure(
	'posix_default',
    #	'bundling',		# enable -rN, require --word
    #	'bundling_override',	# good for -r3, clash --vx -v -x
	'no_ignore_case',
    );

    Getopt::Long::GetOptions(
	"--help"         => sub { print_usage();      CORE::exit( 0 ) },
	"--man"          => sub { do_man();           CORE::exit( 0 ) },

	"--npix=i"       => \$op_npix,
	"--nx=i"         => \$op_nx,
	"--ny=i"         => \$op_ny,
	"--magnify=i"    => \$op_magnify,
	"--wrap=i"       => \$op_wrap,
	"--verbose|v"    => \$op_verbose,
	"--TESTOP"       => \$op_TESTOP,

#		# experimental:
#	# 'bundling_override'  long options clash with bundle options -v -x
#	"vx"             => sub { print( "Test vx =$_[0]:$_[1]=\n" ) },
#	"--test=s"       => sub { print( "=$_[0]:$_[1]=\n" ); die("!FINISH") },
#	"--stuf"         => sub { do_stuf();         die("!FINISH") },

    ) || do {	# GetOptions() returns false on errors in option parsing.
	Error( "Type '$ProgName --help' for usage.\n" );
	CORE::exit( 2 );
	# Do not show usage longer than 5 lines, let user see argument error.
    };

#    print( "ProgFile= $ProgFile\n" );
#    print( "ProgName= $ProgName\n" );


    if ( @ARGV ) {
	Error( "extra arguments:  $ARGV[0]\n" );
    }

    unless ( ($op_magnify > 0) && ($op_magnify <= 20) ) {
	Error( "require [1..20]:  --magnify= $op_magnify\n" );
    }

    unless ( ($op_wrap == 0) || ($op_wrap == 1) ) {
	Error( "require boolean:  --wrap= $op_wrap\n" );
    }

    last  if ( Error() );

    if ( $op_TESTOP ) {
	print( "--npix         = $op_npix\n" );
	print( "--nx           = $op_nx\n" );
	print( "--ny           = $op_ny\n" );
	print( "--magnify      = $op_magnify\n" );
	print( "--wrap         = $op_wrap\n" );
	last;
    }

# Read data stream header.
    my $want   = "Ys,Xs,";
    my $header = <STDIN>;
    last  unless( defined( $header ) );
    chomp( $header );

    unless ( $header =~ m/^$want/ ) {
	Error( "unexpected header line:\n",
	    "    have:  $header\n",
	    "    want:  $want\n"
	);
	last;
    }

    my( $Ys, $Xs, @coeff_name ) = split( ',', $header );

# Top-level object.
    my $tx = ImTop->new(
	Error_sub    => sub{ Error( @_ ) },
    ) || last;

    $tx->Init_required(
	Nx           => $op_nx,
	Ny           => $op_ny,
    );

    $tx->Init_attrib(
	CoeffHeads   => [@coeff_name],
    );

    if ( $op_verbose ) {
	print( "    Top:\n" );
    }

# Image stream object.
    my $sx = ImStream->new(
	Error_sub    => sub{ Error( @_ ) },
    ) || last;

    $sx->Init_attrib(
	Npix         => $op_npix,
	Nx           => $op_nx,
	Ny           => $op_ny,
	MagFactor    => $op_magnify,
	AutoWrap     => $op_wrap,
    );

    last  if ( Error() );

# Stream data to image.
    $tx->go_flow( $sx );

}

CORE::exit( (Error()) ? 1 : 0 );


#---------------------------------------------------------------------------
## functions
#---------------------------------------------------------------------------

# Show man page.
#
sub do_man
{
    my $pager = $ENV{'PAGER'} || "less";

    open( STDOUT, "| $pager" );

    {
	unless ( -r $ProgFile ) {   # message embedded in output
	    print( "Error:  file not found:  $ProgFile\n\n" );
	    last;
	}

#	system( "pod2text -s < $ProgFile" );
	system( "pod2man -s 1 -n $ProgName --center='User Contrib' $ProgFile | nroff -man" );
    }

    close( STDOUT );
    1;
}


#---------------------------------------------------------------------------
## Error Handling
#---------------------------------------------------------------------------

our $Error_cnt = 0;	# (private)

# Error message reporting.
# call:
#    Error( @text )	Print error message, increment error count.
#    Error()		Get error count.
# return:
#    ()  = Error count, false if no errors were recorded.
#
sub Error
{
    if ( @_ ) {
	warn( "Error:  ", @_ );
	$Error_cnt ++;
    }
    return( $Error_cnt );
}


__END__

#---------------------------------------------------------------------------
## Man page
#---------------------------------------------------------------------------
# See also:  perlpod(1)  perlpodstyle(1)

=head1		NAME

simage -- Stream data into an image display.

=head1		SYNOPSIS

 simage  [options]
    --npix=N          number of pixels per read burst
    --nx=N            image N pixels wide
    --ny=N            image N pixels high
    --magnify=1       magnify pixel size by integer factor
    --wrap=1          wrap scan lines at window size (bool)
  options:
    --help            show command usage and exit
    --man             show man page and exit


=head1		DESCRIPTION

Stream data into an image display.  The data stream is one pixel per line,
usually from an FPGA to RaspberryPi program.

Output is a PerlTk window with one or more images displayed.
Intended to build the image in real time as data comes in.

 Input:  (stdin)
 Ys,Xs,c0,c1,c2
 1,0,#0f0000,#000000,#ff0000
 0,1,#0f0000,#000000,#ff0000
 ...

Input data is in CSV format.
Each input line is one pixel containing sync marks (Ys,Xs) and pixel colors
for multiple image columns (c0,c1,..).
Pixel colors are in X11 RGB color format "#rrggbb", and one image will be
produced for each column.

Input Xs,Ys should be 1 only on the pixel where the sweep should reset to
the left edge (Xs) or top edge (Ys) of the image, otherwise 0.
Scanning is assumed to be X-direction fastest.

=head1		OPTIONS

=over 8

=item B<--magnify=N>        - Magnify pixel size by integer factor.

Magnification affects only the pixel size, the window size (nx,ny) is not
scaled.
Typically is a small integer (1..4).

=item B<--help>             - Show command usage and exit.

=item B<--man>              - Show man page and exit.

Prints the manual page and exits.

=back


=head1		RETURN VALUE

0= success, otherwise errors


=head1		EXAMPLES

 Display images for input data.
 % simage < in.data

 Disable auto wrapping of scan lines, --nx is ignored.
 % simage --wrap=0

 Show default options.  Is a hidden test option.
 % simage --TESTOP

 Typical processing pipeline.
 % rpixel --csv | coeff2stream | simage


=head1		TOUBLESHOOTING

=head2			No Ys,Xs sync marks in input stream.

This results in only one scan line at the top of the image.
Inspect the input stream.  Search for ",1," to find Xs sync marks.

Without scan marks use --wrap=1, and --nx=N to specify the number of pixels
per line.
Note --nx must match the actual number of pixels per line, or the image
will look skewed.

=head2			Xs/Ys switched

Scanning expects the X-direction to sweep faster than the Y-direction.
When Xs and Ys are reversed, the Y-direction is reset multiple times
for one X-direction sweep.  This results in all the scan lines being piled
on top of each other at the top of the image.

=head2			Horizontal lines in the image

This can occur when both --wrap=1 and scan marks Xs,Ys are applied, and the
scan line is longer than --nx.  For example, when a 257 pixel line is input
with --nx=256 there is one X-direction reset at pixel 256 (due to --wrap=1),
followed by 1 pixel on the next line which is then reset by Xs.  This gives
a background colored line in the image.

If every line is longer than --nx, then the number of scan lines in the
image is effectively doubled, with every other line having partial data.

With --wrap=0, the extra pixels are discarded beyond the right edge of the
image.

When the scan line is shorter than --nx, the remaining pixels assume the
previous color in that location, usually the background color.


=head1		BUGS

There is no check for number of pixels in each scan line.

When the Y-direction is reset, the new pixels overwrite the exising pixels
in the image.  If the new scan line is shorter, then the remaing old pixels
may be misleading in the image.


=head1		ENVIRONMENT

=over 8

=item B<PAGER>

Value defines an output filter used to display manual pages.
By default, less(1) is used.  If PAGER='', stdout is written with no paging.

=back


=head1		FILES

none

=head1		SEE ALSO

=cut

